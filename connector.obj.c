/*
 * linkino
 * Copyright (C) 2020 Andrea Nardinocchi (andrea@nardinan.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "connector.obj.h"
struct s_connector_attributes *p_connector_alloc(struct s_object *self) {
  struct s_connector_attributes *result = d_prepare(self, connector);
  f_memory_new(self);                                                                 /* inherit */
  f_mutex_new(self);                                                                  /* inherit */
  f_drawable_new(self, (e_drawable_kind_single | e_drawable_kind_force_visibility));  /* inherit */
  return result;
}
struct s_object *f_connector_new(struct s_object *self, struct s_object *drawable, double source_x, double source_y, struct s_connectable_link *link) {
  struct s_connector_attributes *connector_attributes = p_connector_alloc(self);
  if ((connector_attributes->drawable = d_retain(drawable))) {
    connector_attributes->separation = 0.5; /* by default is half of the line */
    d_assert(connector_attributes->starting_point = f_point_new(d_new(point), source_x, source_y));
    d_assert(connector_attributes->destination_point = f_point_new(d_new(point), source_x, source_y));
  }
  connector_attributes->source_link = link;
  connector_attributes->target_weight = 0.0;
  connector_attributes->current_weight = 0.0;
  connector_attributes->snapping_time = d_connector_minimum_time_snap + (rand()%(d_connector_maximum_time_snap - d_connector_minimum_time_snap));
  return self;
}
d_define_method(connector, set_starting)(struct s_object *self, double starting_x, double starting_y, struct s_connectable_link *link) {
  d_using(connector);
  if (connector_attributes->drawable)
    d_call(connector_attributes->starting_point, m_point_set, starting_x, starting_y);
  connector_attributes->source_link = link;
  return self;
}
d_define_method(connector, set_destination)(struct s_object *self, double destination_x, double destination_y, struct s_connectable_link *link) {
  d_using(connector);
  if (connector_attributes->drawable) {
    d_call(connector_attributes->destination_point, m_point_set, destination_x, destination_y);
  }
  connector_attributes->destination_link = link;
  if ((connector_attributes->source_link) && (connector_attributes->destination_link)) {
    connector_attributes->source_link->connector = d_retain(self);
    connector_attributes->destination_link->connector = d_retain(self);
  }
  return self;
}
d_define_method(connector, set_weight)(struct s_object *self, double current_weight) {
  d_using(connector);
  connector_attributes->target_weight = current_weight;
  return self;
}
d_define_method(connector, get_point)(struct s_object *self, double percentage_path, double *position_x, double *position_y) {
  d_using(connector);
  struct s_object *result = NULL;
  /* the whole path is defined by the length of two segments (actually three, but to be quick, we'll consider the horizontal one as a 
   * single segment): the horizontal one and the vertical one. By using the connection points generated by the draw method (segments)
   * we shall calculate the whole length of the path and then advance step-by-step until we found the right point.
   * This is an over-semplification of what we should really do here and can be certanly optimized (e.g. estimate the whole length
   * during the generation of the segments), but I am in a kind of rush.
   * Obvioysly this works only if start and end are present and this connector is completed
   */
  if ((connector_attributes->starting_point) && (connector_attributes->destination_point) && (connector_attributes->source_link) &&
      (connector_attributes->destination_link)) {
    double total_distance = 0.0, distance_to_reach, starting_position_x, starting_position_y;
    for (unsigned int index = 1; connector_attributes->segments[index].initialized; ++index) {
      double distance_squared = (d_math_square((connector_attributes->segments[index].position_x - connector_attributes->segments[index - 1].position_x)) +
          d_math_square((connector_attributes->segments[index].position_y - connector_attributes->segments[index - 1].position_y))),
             distance = f_math_sqrt(distance_squared, d_math_default_precision);
      total_distance += distance;
    }
    /* we got the total distance, so now we have to calculate at which point of the path the point is located. First we need to take into account 
     * the fact that the coordinates are sorted from left top to right bottom.
     */
    d_call(connector_attributes->starting_point, m_point_get, &starting_position_x, &starting_position_y);
    /* if the first point of the segments does not contain the right values, means that the drawing order is currently inverted and the 
     * destination is the starting point ...
     */
    if ((connector_attributes->segments[0].position_x != starting_position_x) &&
        (connector_attributes->segments[0].position_y != starting_position_y)) {
      percentage_path = (1.0 - percentage_path); /* ... and, for this reason, we have to invert the percentage of the total path */
    }
    distance_to_reach = total_distance * percentage_path;
    total_distance = 0.0;
    for (unsigned int index = 1; (connector_attributes->segments[index].initialized); ++index) {
      double distance_squared = (d_math_square((connector_attributes->segments[index].position_x - connector_attributes->segments[index - 1].position_x)) +
          d_math_square((connector_attributes->segments[index].position_y - connector_attributes->segments[index - 1].position_y))),
             distance = f_math_sqrt(distance_squared, d_math_default_precision);
      if ((total_distance + distance) >= distance_to_reach) {
        double percentage_cut;
        /* we got it. Our distance is here, inside this segment. We need to undertand a which point this is by removing from the 'distance_to_reach'
         * the distance estimated so far. We need to normalize the two distances and then to transform the distance into a fraction. We'll use the 
         * fraction to calculate the intersection point. */
        distance_to_reach -= total_distance;
        percentage_cut = (distance_to_reach / distance);
        *position_x = connector_attributes->segments[index - 1].position_x + ((connector_attributes->segments[index].position_x - 
              connector_attributes->segments[index - 1].position_x) * percentage_cut);
        *position_y = connector_attributes->segments[index - 1].position_y + ((connector_attributes->segments[index].position_y -
              connector_attributes->segments[index - 1].position_y) * percentage_cut);
        break;
      }
      total_distance += distance;
    }
    result = self;
  }
  return result;
}
d_define_method(connector, is_over_line)(struct s_object *self, int position_x, int position_y, int line_start_x, int line_start_y, 
    int line_end_x, int line_end_y) {
  struct s_object *result = NULL;
  int delta_y = (line_start_y - line_end_y), delta_x = (line_end_x - line_start_x), w = (line_start_x * line_end_y) - (line_end_x * line_start_y);
  double distance_to_line = ((delta_y * position_x) + (delta_x * position_y) + w)/
    f_math_sqrt(d_math_square(delta_y) + d_math_square(delta_x), d_math_default_precision);
  if (fabs(distance_to_line) < d_connector_selected_line_distance)
    result = self;
  return result;
}
d_define_method(connector, is_over)(struct s_object *self, int position_x, int position_y) {
  d_using(connector);
  struct s_object *result = NULL;
  for (unsigned int index = 1; (connector_attributes->segments[index].initialized) && (!result); ++index) {
    result = d_call(self, m_connector_is_over_line, position_x, position_y, (int)connector_attributes->segments[index - 1].position_x, 
        (int)connector_attributes->segments[index - 1].position_y, (int)connector_attributes->segments[index].position_x, 
        (int)connector_attributes->segments[index].position_y);
  }
  return result;
}
d_define_method(connector, is_snapped)(struct s_object *self) {
  d_using(connector);
  struct s_object *result = NULL;
  if ((time(NULL) - connector_attributes->last_timestamp_below_maximum) > connector_attributes->snapping_time)
    result = self;
  return result;
}
d_define_method_override(connector, draw)(struct s_object *self, struct s_object *environment) {
  d_using(connector);
  struct s_environment_attributes *environment_attributes = d_cast(environment, environment);
  struct s_camera_attributes *camera_attributes = d_cast(environment_attributes->current_camera, camera);
  memset(connector_attributes->segments, 0, (sizeof(struct s_connector_segment) * d_connector_maximum_segments));
  /* we can calculate the weight of the connector by checking he number of elements that generate traffic, and the number of packets currently 
   * traveling in the connector
   */
  if (connector_attributes->target_weight > connector_attributes->current_weight)
    connector_attributes->current_weight += d_connector_increment_weight_per_frame;
  else if (connector_attributes->target_weight < connector_attributes->current_weight)
    connector_attributes->current_weight -= d_connector_increment_weight_per_frame;
  /* eventually, if the load of the arc is below 1.0, we update the timer in order to avoid a possible snap */
  if (connector_attributes->current_weight < d_connector_overload_limitation)
    connector_attributes->last_timestamp_below_maximum = time(NULL);
  if ((connector_attributes->destination_point) && (connector_attributes->drawable)) {
    double starting_position_x, starting_position_y, final_position_x, final_position_y, length_first_half = 0, length_second_half = 0, drawable_width,
           drawable_height, higher_vertical_position, lower_vertical_position, 
           normalized_weight = d_math_min(1.0, d_math_max(connector_attributes->current_weight, 0.0));
    unsigned int current_mask_red = 255, current_mask_green = (unsigned int)((1.0 - normalized_weight) * 255),
                 current_mask_blue = (unsigned int)((1.0 - normalized_weight) * 255);
    int segment_index = 0;
    t_boolean reached;
    /* we need to mask the drawable using the current_weight */
    d_call(connector_attributes->drawable, m_drawable_set_maskRGB, current_mask_red, current_mask_blue, current_mask_green);
    d_call(connector_attributes->drawable, m_drawable_get_dimension, &drawable_width, &drawable_height);
    d_call(connector_attributes->starting_point, m_point_get, &starting_position_x, &starting_position_y);
    d_call(connector_attributes->destination_point, m_point_get, &final_position_x, &final_position_y);
    /* We consider the starting point the leftmost point, and the final one the other one. We also have to consider the highest
     * and the lowest vertical position.
     */
    if (starting_position_x > final_position_x) {
      double backup_position_x = starting_position_x, backup_position_y = starting_position_y;
      starting_position_x = final_position_x;
      starting_position_y = final_position_y;
      final_position_x = backup_position_x;
      final_position_y = backup_position_y;
    }
    if (final_position_y > starting_position_y) {
      higher_vertical_position = final_position_y;
      lower_vertical_position = starting_position_y;
    } else {
      higher_vertical_position = starting_position_y;
      lower_vertical_position = final_position_y;
    }
    /* The y component has to be shifted because the pivoting of the object is done in respect of its center. This means that the
     * whole line will move down by half of the width of the image */
    higher_vertical_position += (drawable_width / 2.0);
    lower_vertical_position += (drawable_width / 2.0);
    /* The line is composed by two (or three) components that are associated respectively to a horizontal displacement,
     * a vertical displacement and another horizontal displacement:
     *  - first horizontal part (displacement in X)
     *  - vertical optional part (displacement in Y)
     *  - second horizontal part (displacement in X)
     *  The separation between the first and the second line happens at 0.5 (or, more precisely at "separation") of the total horizontal
     *  length of the line.
     */
    length_first_half = connector_attributes->separation * (final_position_x - starting_position_x) - drawable_height;
    length_second_half = (1.0 - connector_attributes->separation) * (final_position_x - starting_position_x) - drawable_height;
    d_call(connector_attributes->drawable, m_drawable_set_angle, 0.0);
    reached = d_false;
    connector_attributes->segments[segment_index].initialized = d_true;
    connector_attributes->segments[segment_index].position_x = starting_position_x;
    connector_attributes->segments[segment_index].position_y = starting_position_y;
    for (double position_x = starting_position_x; (!reached); position_x += drawable_width) {
      d_call(connector_attributes->drawable, m_drawable_set_position, position_x, starting_position_y);
      if (position_x >= (starting_position_x + length_first_half)) {
        break;
      } else if ((position_x + drawable_width) > (starting_position_x + length_first_half)) {
        d_call(connector_attributes->drawable, m_drawable_set_dimension_w, ((starting_position_x + length_first_half) - position_x));
        reached = d_true;
      } else
        d_call(connector_attributes->drawable, m_drawable_set_dimension_w, drawable_width);
      if ((d_call(connector_attributes->drawable, m_drawable_normalize_scale, camera_attributes->scene_reference_w, camera_attributes->scene_reference_h,
              camera_attributes->scene_offset_x, camera_attributes->scene_offset_y, camera_attributes->scene_center_x, camera_attributes->scene_center_y,
              camera_attributes->screen_w, camera_attributes->screen_h, camera_attributes->scene_zoom)))
        while (((intptr_t)d_call(connector_attributes->drawable, m_drawable_draw, environment)) == d_drawable_return_continue);
    }
    connector_attributes->segments[++segment_index].initialized = d_true;
    connector_attributes->segments[segment_index].position_x = (starting_position_x + length_first_half);
    connector_attributes->segments[segment_index].position_y = starting_position_y;
    reached = d_false;
    connector_attributes->segments[++segment_index].initialized = d_true;
    connector_attributes->segments[segment_index].position_x = (final_position_x - length_second_half);
    connector_attributes->segments[segment_index].position_y = final_position_y;
    for (double position_x = (final_position_x - length_second_half); (!reached); position_x += drawable_width) {
      d_call(connector_attributes->drawable, m_drawable_set_position, position_x, final_position_y);
      if (position_x >= final_position_x) {
        break;
      } else if ((position_x + drawable_width) > final_position_x) {
        d_call(connector_attributes->drawable, m_drawable_set_dimension_w, (final_position_x - position_x));
        reached = d_true;
      } else
        d_call(connector_attributes->drawable, m_drawable_set_dimension_w, drawable_width);
      if ((d_call(connector_attributes->drawable, m_drawable_normalize_scale, camera_attributes->scene_reference_w, camera_attributes->scene_reference_h,
              camera_attributes->scene_offset_x, camera_attributes->scene_offset_y, camera_attributes->scene_center_x, camera_attributes->scene_center_y,
              camera_attributes->screen_w, camera_attributes->screen_h, camera_attributes->scene_zoom)))
        while (((intptr_t)d_call(connector_attributes->drawable, m_drawable_draw, environment)) == d_drawable_return_continue);
    }
    connector_attributes->segments[++segment_index].initialized = d_true;
    connector_attributes->segments[segment_index].position_x = final_position_x;
    connector_attributes->segments[segment_index].position_y = final_position_y;
    if (higher_vertical_position > lower_vertical_position) {
      d_call(connector_attributes->drawable, m_drawable_set_angle, 90.0);
      reached = d_false;
      for (double position_y = lower_vertical_position; (!reached); position_y += drawable_width) {
        d_call(connector_attributes->drawable, m_drawable_set_position, (starting_position_x + length_first_half), position_y);
        if (position_y >= higher_vertical_position) {
          break;
        } else if ((position_y + drawable_width) > higher_vertical_position) {
          d_call(connector_attributes->drawable, m_drawable_set_dimension_w, (higher_vertical_position - position_y));
          reached = d_true;
        } else
          d_call(connector_attributes->drawable, m_drawable_set_dimension_w, drawable_width);
        if ((d_call(connector_attributes->drawable, m_drawable_normalize_scale, camera_attributes->scene_reference_w, camera_attributes->scene_reference_h,
                camera_attributes->scene_offset_x, camera_attributes->scene_offset_y, camera_attributes->scene_center_x, camera_attributes->scene_center_y,
                camera_attributes->screen_w, camera_attributes->screen_h, camera_attributes->scene_zoom)))
          while (((intptr_t)d_call(connector_attributes->drawable, m_drawable_draw, environment)) == d_drawable_return_continue);
      }
    }
    /* we need to restore the right size before leaving */
    d_call(connector_attributes->drawable, m_drawable_set_dimension_w, drawable_width);
  }
  d_cast_return(d_drawable_return_last);
}
d_define_method(connector, destroy_links)(struct s_object *self) {
  d_using(connector);
  if ((connector_attributes->destination_link) && (connector_attributes->destination_link->connector)) {
    d_delete(connector_attributes->destination_link->connector);
    connector_attributes->destination_link->connector = NULL;
  }
  if ((connector_attributes->source_link) && (connector_attributes->source_link->connector)) {
    d_delete(connector_attributes->source_link->connector);
    connector_attributes->source_link->connector = NULL;
  }
  return self;
}
d_define_method(connector, delete)(struct s_object *self, struct s_connector_attributes *attributes) {
  printf("has been deleted\n");
  if ((attributes->destination_link) && (attributes->destination_link->connector)) {
    d_delete(attributes->destination_link->connector);
    attributes->destination_link->connector = NULL;
  }
  if ((attributes->source_link) && (attributes->source_link->connector)) {
    d_delete(attributes->source_link->connector);
    attributes->source_link->connector = NULL;
  }
  if (attributes->drawable)
    d_delete(attributes->drawable);
  if (attributes->starting_point)
    d_delete(attributes->starting_point);
  if (attributes->destination_point)
    d_delete(attributes->destination_point);
  return NULL;
}
d_define_class(connector) {d_hook_method(connector, e_flag_public, set_starting),
  d_hook_method(connector, e_flag_public, set_destination),
  d_hook_method(connector, e_flag_public, set_weight),
  d_hook_method(connector, e_flag_public, get_point),
  d_hook_method(connector, e_flag_private, is_over_line),
  d_hook_method(connector, e_flag_public, is_over),
  d_hook_method(connector, e_flag_public, is_snapped),
  d_hook_method_override(connector, e_flag_public, drawable, draw),
  d_hook_method(connector, e_flag_public, destroy_links),
  d_hook_delete(connector),
  d_hook_method_tail};
